# Invoke an Xstate Service when Enterine a state

[Video link](https://egghead.io/lessons/react-invoke-an-xstate-service-when-entering-a-state)
[Code Link](https://github.com/isaacplmann/sturdy-uis/tree/lesson2-end)

- We can reuse the `fetchMachine` in either the same component or different components.
  - If we plan on reusing this `machine` it is good to plan ahead and decided what logic should be passed in as an argument and what logic should be delegated inside the machine.
- When delegating logic to inside the machine, we can achieve this by having the `pending` state `invoke` a service.

**Note:** `services` can return promises, observables, and even other machines.

ğŸ§™â€â™‚ï¸ [Invoke](https://xstate.js.org/docs/guides/communication.html#the-invoke-property) is defined in a state node's configuration whose value is an object that contains:
  - `src`, `id`, `onError`, `autoForward`, and `data`
    - `src` can be:
      - A machine
      - A function that returns a `Promise`
      - A function that returns a "callback handler"
      - A function that returns an observable
      - A string, which refers to any of the 3 listed options defined in the machine's `options.services`

âš ï¸ This `onDone` property and `invoke.onDone` are similar transitions, but refer to different things.

- Xstate can [invoke promises](https://xstate.js.org/docs/guides/communication.html#invoking-promises) as-is.
  - Can `resolve()` which will take `onDone` transition or it can `reject()` which will take `onError` transition.
    - `onError` data is available on the event's `data` property.
    âš ï¸ If `onError` transition is missing and the `Promise` is rejected, the error will be ignored.

ğŸ“ **Note:** _If the state where the invoked promise is active is exited before the promise settles, the result of the promise is discarded._

â†ªï¸ Xstate can [invoke callbacks](https://xstate.js.org/docs/guides/communication.html#invoking-callbacks)
  - Defined as streams of events sent to the parent machine which are modeled via a callback handler. The callback handler is a function that takes two arguments:
    - `callback` - called with the event to be sent.
    - `onReceive` - called with the listern that listens to events from the parent.

ğŸ”® Xstate can [invoke observables](https://xstate.js.org/docs/guides/communication.html#invoking-observables)
  - Defined as streams of values emmited over time.
  - Uni-directional, it can only send events to the parent machine, not receive them.

ğŸšœ When xstate [invoke machines](https://xstate.js.org/docs/guides/communication.html#invoking-machines), they communicate hierarchicaclly, and invoked machines can communicate `Parent-to-child` or `Child-to-parent`
  - ğŸ” Child machines can be [invoked with `context`](https://xstate.js.org/docs/guides/communication.html#invoking-machines) that is derived from the parent's machine context.

```js
export const fetchMachine = Machine({
	...

	pending: {
		invoke: {
			src: 'fetchData', ğŸ‘ˆ// can define a service directly
            onDone: { target: 'successful', actions: ['setResults'] },
			onError: { target: 'failed', actions: ['setMessage'] }
		}       ğŸ‘†ğŸ‘† // onDone and onError are both transitions
	}                // they are envents autogenerated by xState
	...

})
```

By delegating this logic to inside the machine itself, `fetchData` is no longer an action, it's a [service](https://xstate.js.org/docs/guides/communication.html).

Because we now `invoke` a `fetchData` as a service, the values stored inside `event` is now represented by a `data` property:

```js
actions: {
  setResults: assign((ctx, event: any) => ({
    results: event.data, ğŸ‘ˆ // update from result to data
  }));
  setMessage: assign((ctx, event: any) => ({
    message: event.data, ğŸ‘ˆ // update from message to data
  }));
}
```

We must also update our `useMachines` to represent the update from `action` to `service`

```js
const [fetchPeopleState, sendToPeopleMachine] = useMachine(fetchMachine, {
  services: { ğŸ‘ˆ// update to services key
    fetchData: (ctx, event) => {
      return fetchPeople().then((r) => r.results);
    },
  },
});
```
